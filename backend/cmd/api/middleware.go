package main

import (
	"net/http"

	"github.com/rs/cors"
)

func (app *application) recoverPanic(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				w.Header().Set("connection", "close")

				app.serveErrorResponse(w, r, err.(error))
			}
		}()
		next.ServeHTTP(w, r)
	})
}

// func (app *application) enableCORS(next http.Handler) http.Handler {
// 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
// 		w.Header().Add("Vary", "Origin")

// 		w.Header().Add("Vary", "Access-Control-Request-Method")

// 		origin := r.Header.Get("Origin")

// 		if origin != "" && len(app.config.cors.trustedOrigins) != 0 {
// 			for i := range app.config.cors.trustedOrigins {
// 				if origin == app.config.cors.trustedOrigins[i] {
// 					w.Header().Set("Access-Control-Allow-Origin", origin)

// 					// Check if the request has the HTTP method OPTIONS and contains the
// 					// "Access-Control-Request-Method" header. If it does, then we treat
// 					// it as a preflight request.
// 					if r.Method == http.MethodOptions && r.Header.Get("Access-Control-Request-Method") != "" {
// 						w.Header().Set("Access-Control-Allow-Methods", "OPTIONS, PUT, PATCH, DELETE")
// 						w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")

// 						w.WriteHeader(http.StatusOK)
// 						return
// 					}
// 				}
// 			}
// 		}
// 		next.ServeHTTP(w, r)
// 	})
// }

func (app *application) enableCORS(next http.Handler) http.Handler {
	c := cors.New(app.config.cors)
	return c.Handler(next)
}
